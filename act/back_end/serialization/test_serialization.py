#===- act/back_end/serialization/test_serialization.py - ACT Serialization Tests -----====#
# ACT: Abstract Constraint Transformer
# Copyright (C) 2025– ACT Team
#
# Licensed under the GNU Affero General Public License v3.0 or later (AGPLv3+).
# Distributed without any warranty; see <http://www.gnu.org/licenses/>.
#===---------------------------------------------------------------------===#
#
# Purpose:
#   Test suite for ACT Net JSON serialization and deserialization.
#   Uses networks generated by the examples factory for comprehensive testing.
#
#===---------------------------------------------------------------------===#

import json
import tempfile
import os
from pathlib import Path

try:
    import torch
    HAS_TORCH = True
except ImportError:
    HAS_TORCH = False
    torch = None

from act.back_end.core import Layer, Net
from act.back_end.serialization import (
    save_net_to_file, load_net_from_file, 
    save_net_to_string, load_net_from_string,
    validate_json_schema,
    TensorEncoder, NetSerializer
)

# Import for loading networks from examples
# (No longer using old factory - loading directly from JSON files)


def create_test_networks():
    """Load all ACT networks from the examples folder using proper deserialization."""
    examples_dir = Path("act/back_end/examples/nets")
    test_nets = {}

    # Gather JSON files
    json_files = sorted(examples_dir.glob("*.json"))
    if not json_files:
        raise RuntimeError(f"No network JSON files found in {examples_dir}")

    print(f"Loading {len(json_files)} networks from {examples_dir}...")

    # Use proper ACT serialization for loading
    from act.back_end.serialization.serialization import load_net_from_file

    for json_file in json_files:
        net_name = json_file.stem
        try:
            # Use proper deserialization which handles tensor decoding and validation gracefully
            # Force CPU device for CI environments that don't have CUDA
            net, metadata = load_net_from_file(str(json_file), target_device='cpu')
            
            # Get architecture type from metadata or infer from filename
            arch_type = metadata.get('architecture_type', 'unknown')
            
            print(f"  ✓ Loaded {net_name}: {len(net.layers)} layers, {arch_type} type")
            test_nets[net_name] = net
            
        except Exception as e:
            print(f"  ❌ Failed to load {net_name}: {e}")
            # For testing purposes, we'll skip failed networks but continue
            continue

    if not test_nets:
        raise RuntimeError("No networks could be loaded successfully")

    print(f"Successfully loaded {len(test_nets)} test networks")
    return test_nets


def test_basic_serialization():
    """Test basic serialization and deserialization on all available networks."""
    print("🧪 Testing basic serialization...")
    
    # Load test networks from examples
    test_nets = create_test_networks()
    
    # Test all available networks
    passed = 0
    failed = 0
    passed_nets = []
    failed_nets = []
    
    for net_name, net in test_nets.items():
        try:
            print(f"  Testing network '{net_name}' with {len(net.layers)} layers...")
            
            # Test serialization using NetSerializer
            serialized_dict = NetSerializer.serialize_net(net)
            
            json_str = json.dumps(serialized_dict, indent=2)
            print(f"    Serialized to {len(json_str)} characters")
            
            # Test deserialization
            deserialized_net, metadata = NetSerializer.deserialize_net(serialized_dict)
            print(f"    Deserialized network with {len(deserialized_net.layers)} layers")
            
            # Verify structure
            assert len(net.layers) == len(deserialized_net.layers), f"Layer count mismatch for {net_name}"
            assert net.layers[0].kind == deserialized_net.layers[0].kind, f"Layer kind mismatch for {net_name}"
            
            # Additional verification for networks with multiple layers
            if len(net.layers) > 1:
                assert net.layers[-1].kind == deserialized_net.layers[-1].kind, f"Last layer kind mismatch for {net_name}"
            
            print(f"    ✅ {net_name} passed")
            passed += 1
            passed_nets.append(net_name)
            
        except Exception as e:
            print(f"    ❌ {net_name} failed: {e}")
            failed += 1
            failed_nets.append(net_name)
    
    print(f"✅ Basic serialization test completed: {passed} passed, {failed} failed")
    if passed_nets:
        print(f"  ✅ Passed: {', '.join(passed_nets)}")
    if failed_nets:
        print(f"  ❌ Failed: {', '.join(failed_nets)}")
    
    # Ensure at least one network was tested successfully
    assert passed > 0, "No networks passed serialization testing"
    
    # Optionally fail if any network failed (for strict testing)
    if failed > 0:
        print(f"⚠️  Warning: {failed} networks failed serialization testing")


def test_file_io():
    """Test file input/output operations on all available networks."""
    print("🧪 Testing file I/O...")
    
    if not HAS_TORCH:
        print("⏭️  Skipping - PyTorch not available")
        return
    
    # Test all available networks
    test_nets = create_test_networks()
    
    passed = 0
    failed = 0
    
    for net_name, net in test_nets.items():
        print(f"  Testing file I/O for '{net_name}'...")
        
        # Test file save/load
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            filepath = f.name
        
        try:
            # Save to file
            metadata = {
                "description": f"Test network: {net_name}",
                "network_name": net_name,
                "test_case": "file_io"
            }
            save_net_to_file(net, filepath, metadata)
            assert os.path.exists(filepath), f"File not created for {net_name}"
            
            # Check file size
            file_size = os.path.getsize(filepath)
            print(f"    File size: {file_size:,} bytes")
            
            # Load from file
            net_restored, loaded_metadata = load_net_from_file(filepath)
            
            # Verify metadata preservation
            assert loaded_metadata["description"] == metadata["description"], f"Description mismatch for {net_name}"
            assert loaded_metadata["test_case"] == metadata["test_case"], f"Test case mismatch for {net_name}"
            assert loaded_metadata["network_name"] == net_name, f"Network name mismatch for {net_name}"
            
            # Verify structure
            assert len(net.layers) == len(net_restored.layers), f"Layer count mismatch for {net_name}"
            
            print(f"    ✅ {net_name} passed")
            passed += 1
            
        except Exception as e:
            print(f"    ❌ {net_name} failed: {e}")
            failed += 1
            
        finally:
            # Cleanup
            if os.path.exists(filepath):
                os.unlink(filepath)
    
    print(f"✅ File I/O test completed: {passed} passed, {failed} failed")
    assert passed > 0, "No networks passed file I/O testing"


def test_device_migration():
    """Test device migration during serialization and deserialization on all networks."""
    print("🧪 Testing device migration...")
    test_nets = create_test_networks()
    
    passed = 0
    failed = 0
    
    for net_name, net in test_nets.items():
        print(f"  Testing device migration for '{net_name}'...")
        
        try:
            # Test serialization and deserialization
            metadata = {"test": "device_migration", "network_name": net_name}
            serialized = save_net_to_string(net, metadata)
            net_restored, loaded_metadata = load_net_from_string(serialized)
            
            # Verify metadata and structure
            assert loaded_metadata["test"] == "device_migration", f"Metadata mismatch for {net_name}"
            assert loaded_metadata["network_name"] == net_name, f"Network name mismatch for {net_name}"
            assert len(net.layers) == len(net_restored.layers), f"Layer count mismatch for {net_name}"
            
            print(f"    ✅ {net_name} passed")
            passed += 1
            
        except Exception as e:
            print(f"    ❌ {net_name} failed: {e}")
            failed += 1
    
    print(f"✅ Device migration test completed: {passed} passed, {failed} failed")
    assert passed > 0, "No networks passed device migration testing"


def test_schema_validation():
    """Test JSON schema validation."""
    print("🧪 Testing schema validation...")
    
    # Test valid schema
    valid_json = {
        "format_version": "1.0",
        "act_net": {
            "layers": [
                {
                    "id": 0,
                    "kind": "INPUT",
                    "params": {},
                    "meta": {"shape": [1, 784]},
                    "in_vars": [0],
                    "out_vars": [0],
                    "cache": {}
                }
            ],
            "graph": {"preds": {}, "succs": {}},
            "metadata": {}
        }
    }
    
    errors = validate_json_schema(valid_json)
    assert len(errors) == 0, f"Valid schema failed validation: {errors}"
    
    # Test invalid schema
    invalid_json = {
        "act_net": {
            "layers": [
                {
                    "id": 0,
                    "kind": "INPUT",
                    # Missing required fields
                }
            ]
        }
        # Missing format_version
    }
    
    errors = validate_json_schema(invalid_json)
    assert len(errors) > 0, "Invalid schema passed validation"
    
    print(f"Schema validation caught {len(errors)} errors as expected")
    print("✅ Schema validation test passed")


def test_complex_metadata():
    """Test serialization of complex metadata structures on all networks."""
    print("🧪 Testing complex metadata...")
    
    if not HAS_TORCH:
        print("⏭️  Skipping - PyTorch not available")
        return
    
    # Test all available networks
    test_nets = create_test_networks()
    
    passed = 0
    failed = 0
    
    for net_name, net in test_nets.items():
        print(f"  Testing complex metadata for '{net_name}'...")
        
        try:
            # Serialize with complex metadata at the net level
            complex_metadata = {
                "network_name": net_name,
                "model_info": {
                    "optimizer": "adam",
                    "lr_schedule": [0.001, 0.0001, 0.00001],
                    "regularization": {"l2": 1e-4, "dropout": 0.5}
                },
                "tags": ["test", "serialization", net_name.split('_')[0]],
                "training_config": {
                    "batch_size": 32,
                    "epochs": 100
                }
            }
            
            json_str = save_net_to_string(net, complex_metadata)
            net_restored, metadata_restored = load_net_from_string(json_str)
            
            # Verify complex metadata preservation
            assert metadata_restored["network_name"] == net_name, f"Network name mismatch for {net_name}"
            assert metadata_restored["model_info"]["optimizer"] == "adam", f"Optimizer mismatch for {net_name}"
            assert metadata_restored["tags"][0] == "test", f"Tags mismatch for {net_name}"
            assert metadata_restored["training_config"]["batch_size"] == 32, f"Batch size mismatch for {net_name}"
            
            # Verify structure
            assert len(net.layers) == len(net_restored.layers), f"Layer count mismatch for {net_name}"
            
            print(f"    ✅ {net_name} passed")
            passed += 1
            
        except Exception as e:
            print(f"    ❌ {net_name} failed: {e}")
            failed += 1
    
    print(f"✅ Complex metadata test completed: {passed} passed, {failed} failed")
    assert passed > 0, "No networks passed complex metadata testing"


def run_all_tests():
    """Run all serialization tests."""
    print("🚀 Running ACT Serialization Test Suite")
    print("=" * 50)
    
    tests = [
        test_basic_serialization,
        test_file_io, 
        test_device_migration,
        test_schema_validation,
        test_complex_metadata
    ]
    
    passed = 0
    failed = 0
    
    for test in tests:
        try:
            test()
            passed += 1
        except Exception as e:
            print(f"❌ {test.__name__} failed: {e}")
            import traceback
            traceback.print_exc()
            failed += 1
        print()
    
    print("=" * 50)
    print(f"Test Results: {passed} passed, {failed} failed")
    
    if failed == 0:
        print("🎉 All tests passed!")
    else:
        print("⚠️  Some tests failed")
    
    return failed == 0


def main():
    """Main function with options for testing and demo."""
    import sys
    
    print("🧪 Running ACT Serialization Test Suite")
    success = run_all_tests()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
